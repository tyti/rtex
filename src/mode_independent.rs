use crate::command::{prefixed_command, ShowCommand, UnexpandableCommand};
use crate::eqtb::{ControlSequence, Eqtb, IntegerVariable, TokenListVariable};
use crate::horizontal_mode::HorizontalModeType;
use crate::hyphenation::Hyphenator;
use crate::input::Scanner;
use crate::integer::{Integer, IntegerExt};
use crate::logger::{InteractionMode, Logger};
use crate::main_control::report_illegal_case;
use crate::nodes::{show_box, LanguageNode, Node, SpecialNode, WhatsitNode};
use crate::output::Output;
use crate::page_breaking::PageBuilder;
use crate::print::string::StringPrinter;
use crate::print::{Printer, MAX_PRINT_LINE};
use crate::semantic_nest::{RichMode, SemanticState};
use crate::token::Token;
use crate::token_lists::{print_meaning, the_toks, token_show};
use crate::{norm_min, open_in};

use std::ffi::OsString;
use std::io::BufReader;
use std::os::unix::ffi::OsStringExt;
use std::path::PathBuf;

/// See 1270.
pub fn do_assignments(
    hyphenator: &mut Hyphenator,
    page_builder: &mut PageBuilder,
    output: &mut Output,
    nest: &mut SemanticState,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) -> (UnexpandableCommand, Token) {
    loop {
        let (unexpandable_command, token) =
            scanner.get_next_non_blank_non_relax_non_call_token(eqtb, logger);
        let UnexpandableCommand::Prefixable(prefixable_command) = unexpandable_command else {
            return (unexpandable_command, token);
        };
        logger.set_box_allowed = false;
        prefixed_command(
            prefixable_command,
            token,
            hyphenator,
            page_builder,
            output,
            nest,
            scanner,
            eqtb,
            logger,
        );
        logger.set_box_allowed = true;
    }
}

/// See 1275.
pub fn open_read_file(scanner: &mut Scanner, eqtb: &mut Eqtb, logger: &mut Logger) {
    let n = Integer::scan_four_bit_int(scanner, eqtb, logger) as usize;
    scanner.read_file[n] = None;
    scanner.scan_optional_equals(eqtb, logger);
    let file_name = scanner.scan_file_name(eqtb, logger);
    let mut path = PathBuf::from(OsString::from_vec(file_name));

    if path.extension().is_none() {
        path.set_extension("tex");
    }
    if let Ok(file) = open_in(&path) {
        scanner.read_file[n] = Some(BufReader::new(file));
    }
}

/// See 1275.
pub fn close_read_file(scanner: &mut Scanner, eqtb: &mut Eqtb, logger: &mut Logger) {
    let n = Integer::scan_four_bit_int(scanner, eqtb, logger) as usize;
    scanner.read_file[n] = None;
}

/// See 1279
pub fn issue_message(
    is_err: bool,
    token: Token,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    let Token::CSToken { cs } = token else {
        panic!("Impossible")
    };
    let def_ref = scanner.scan_toks(cs, true, eqtb, logger);
    let mut string_printer = StringPrinter::new(eqtb.get_current_escape_character());
    token_show(&def_ref, &mut string_printer, eqtb);
    let s = string_printer.into_string();
    if is_err {
        print_string_as_error_message(&s, scanner, eqtb, logger);
    } else {
        print_string_on_terminal(&s, logger);
    }
}

/// See 1280.
fn print_string_on_terminal(s: &[u8], logger: &mut Logger) {
    if logger.term_offset + s.len() > MAX_PRINT_LINE - 2 {
        logger.print_ln();
    } else if logger.term_offset > 0 || logger.file_offset > 0 {
        logger.print_char(b' ');
    }
    logger.slow_print_str(s);
    logger.update_terminal();
}

/// See 1283.
fn print_string_as_error_message(
    s: &[u8],
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    logger.print_err("");
    logger.slow_print_str(s);
    let help: &[&str] = if logger.long_help_seen {
        &["(That was another \\errmessage.)"]
    } else {
        &[
            "This error message was generated by an \\errmessage",
            "command, so I can't give any explicit help.",
            "Pretend that you're Hercule Poirot: Examine all clues,",
            "and deduce the truth by order and method.",
        ]
    };
    if eqtb.token_lists.get(TokenListVariable::ErrHelp).is_some() {
        logger.use_err_help = true;
        logger.error(help, scanner, eqtb);
        logger.use_err_help = false;
    } else {
        if logger.interaction != InteractionMode::ErrorStop {
            logger.long_help_seen = true;
        }
        logger.error(help, scanner, eqtb);
    }
}

/// See 1288.
pub fn shift_to_upper_case(
    token: Token,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    let Token::CSToken { cs } = token else {
        panic!("Impossible")
    };
    let mut token_list = scanner.scan_toks(cs, false, eqtb, logger);
    for token in &mut token_list {
        change_token_to_upper_case(token, eqtb);
    }
    scanner.back_list(token_list, eqtb, logger);
}

/// See 1288.
pub fn shift_to_lower_case(
    token: Token,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    let Token::CSToken { cs } = token else {
        panic!("Impossible")
    };
    let mut token_list = scanner.scan_toks(cs, false, eqtb, logger);
    for token in &mut token_list {
        change_token_to_lower_case(token, eqtb);
    }
    scanner.back_list(token_list, eqtb, logger);
}

/// See 1289.
fn change_token_to_upper_case(token: &mut Token, eqtb: &Eqtb) {
    match token {
        Token::LeftBrace(c)
        | Token::RightBrace(c)
        | Token::MathShift(c)
        | Token::TabMark(c)
        | Token::MacParam(c)
        | Token::SuperMark(c)
        | Token::SubMark(c)
        | Token::Spacer(c)
        | Token::Letter(c)
        | Token::OtherChar(c) => {
            let new_character = eqtb.uc_code(*c as usize);
            if new_character != 0 {
                *c = new_character as u8;
            }
        }
        Token::CSToken { cs } => {
            // Active characters are also changed.
            if let ControlSequence::Active(c) = cs {
                let new_c = eqtb.uc_code((*c) as usize);
                if new_c != 0 {
                    *c = new_c as u8;
                }
            }
        }
        Token::Null => {
            panic!("Should not appear here")
        }
    }
}

/// See 1289.
fn change_token_to_lower_case(token: &mut Token, eqtb: &Eqtb) {
    match token {
        Token::LeftBrace(c)
        | Token::RightBrace(c)
        | Token::MathShift(c)
        | Token::TabMark(c)
        | Token::MacParam(c)
        | Token::SuperMark(c)
        | Token::SubMark(c)
        | Token::Spacer(c)
        | Token::Letter(c)
        | Token::OtherChar(c) => {
            let new_character = eqtb.lc_code(*c as usize);
            if new_character != 0 {
                *c = new_character as u8;
            }
        }
        Token::CSToken { cs } => {
            // Active characters are also changed.
            if let ControlSequence::Active(c) = cs {
                let new_c = eqtb.lc_code((*c) as usize);
                if new_c != 0 {
                    *c = new_c as u8;
                }
            }
        }
        Token::Null => {
            panic!("Should not appear here")
        }
    }
}

/// See 1293.
pub fn show_whatever(
    show_command: ShowCommand,
    nest: &SemanticState,
    page_builder: &PageBuilder,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    match show_command {
        ShowCommand::Show => show_current_meaning_of_token(scanner, eqtb, logger),
        ShowCommand::ShowBox => {
            show_current_contents_of_box(scanner, eqtb, logger);
            complete_potentially_long_show_command(eqtb, logger);
        }
        ShowCommand::ShowThe => {
            show_current_value_of_some_parameter_or_register(scanner, eqtb, logger)
        }
        ShowCommand::ShowLists => {
            logger.begin_diagnostic(eqtb.tracing_online());
            nest.show_activities(page_builder, eqtb, logger);
            complete_potentially_long_show_command(eqtb, logger);
        }
    }
    let help: &[_] = if logger.interaction != InteractionMode::ErrorStop {
        logger.error_count -= 1;
        &[]
    } else if eqtb.tracing_online() > 0 {
        &[
            "This isn't an error message; I'm just \\showing something.",
            "Type `I\\show...' to show more (e.g., \\show\\cs,",
            "\\showthe\\count10, \\showbox255, \\showlists).",
        ]
    } else {
        &[
            "This isn't an error message; I'm just \\showing something.",
            "Type `I\\show...' to show more (e.g., \\show\\cs,",
            "\\showthe\\count10, \\showbox255, \\showlists).",
            "And type `I\\tracingonline=1\\show...' to show boxes and",
            "lists on your terminal as well as in the transcript file.",
        ]
    };
    logger.error(help, scanner, eqtb);
}

/// See 1294.
fn show_current_meaning_of_token(scanner: &mut Scanner, eqtb: &mut Eqtb, logger: &mut Logger) {
    let (command, token) = scanner.get_command_and_token(eqtb, logger);
    logger.print_nl_str("> ");
    if let Token::CSToken { cs } = token {
        cs.sprint_cs(eqtb, logger);
        logger.print_char(b'=');
    }
    print_meaning(command, logger, eqtb);
}

/// See 1296.
fn show_current_contents_of_box(scanner: &mut Scanner, eqtb: &mut Eqtb, logger: &mut Logger) {
    let register = scanner.scan_register_index(eqtb, logger);
    logger.begin_diagnostic(eqtb.tracing_online());
    logger.print_nl_str("> \\box");
    logger.print_int(register as i32);
    logger.print_char(b'=');
    match eqtb.boks(register) {
        None => {
            logger.print_str("void");
        }
        Some(list_node) => {
            show_box(list_node, eqtb, logger);
        }
    }
}

/// See 1297.
fn show_current_value_of_some_parameter_or_register(
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    let token_list = the_toks(scanner, eqtb, logger);
    logger.print_nl_str("> ");
    token_show(&token_list, logger, eqtb);
}

/// See 1298.
fn complete_potentially_long_show_command(eqtb: &Eqtb, logger: &mut Logger) {
    logger.end_diagnostic(true);
    logger.print_err("OK");
    if logger.terminal_logging && eqtb.tracing_online() <= 0 {
        // Temporarily disable logging to file.
        let log_file = std::mem::take(&mut logger.log_file);
        logger.print_str(" (see the transcript file)");
        logger.log_file = log_file;
    }
}

/// See 1348.
pub fn do_special(
    token: Token,
    nest: &mut SemanticState,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    let node = Node::Whatsit(WhatsitNode::Special(implement_special(
        token, scanner, eqtb, logger,
    )));
    nest.tail_push(node, eqtb);
}

/// See 1348.
pub fn set_language(
    nest: &mut SemanticState,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) {
    if let Some(language_node) = implement_setlanguage(nest, scanner, eqtb, logger) {
        let node = Node::Whatsit(WhatsitNode::Language(language_node));
        nest.tail_push(node, eqtb);
    }
}

/// See 1354.
fn implement_special(
    token: Token,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) -> SpecialNode {
    let Token::CSToken { cs } = token else {
        panic!("Impossible")
    };
    let token_list = scanner.scan_toks(cs, true, eqtb, logger);
    SpecialNode {
        tokens: std::rc::Rc::new(token_list),
    }
}

/// See 1377.
fn implement_setlanguage(
    nest: &mut SemanticState,
    scanner: &mut Scanner,
    eqtb: &mut Eqtb,
    logger: &mut Logger,
) -> Option<LanguageNode> {
    match nest.mode_mut() {
        RichMode::Horizontal(hmode) => {
            let value = Integer::scan_int(scanner, eqtb, logger);
            let language = if value <= 0 || value > 255 {
                0
            } else {
                value as usize
            };
            if let HorizontalModeType::Unrestricted { clang, .. } = &mut hmode.subtype {
                *clang = language as u16;
            }
            Some(LanguageNode {
                language,
                left_hyphen_min: norm_min(eqtb.integer(IntegerVariable::LeftHyphenMin)),
                right_hyphen_min: norm_min(eqtb.integer(IntegerVariable::RightHyphenMin)),
            })
        }
        _ => {
            report_illegal_case(UnexpandableCommand::SetLanguage, scanner, eqtb, logger);
            None
        }
    }
}
